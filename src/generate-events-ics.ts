import { addDays } from 'date-fns';

import { generateEventUID } from './utils/article-utils.js';
import { generateICSDatetime } from './utils/date-utils.js';
import { getEventsJSON, saveEventsICS } from './utils/utils.js';
import logger from './utils/log-utils.js';

const LINE_BREAK = '\r\n';

const DATE_TODAY = new Date().toISOString();
const DATE_CREATED = generateICSDatetime(DATE_TODAY);

const wordWrap = (heading, content) => {
    const lineLength = 75;
    const continuationPrefix = `${LINE_BREAK} `;
    const continuationLineLength = lineLength - continuationPrefix.length;

    const combinedContent = `${heading}:${content}`;

    const segments: string[] = [];

    // Add the initial text, which can use the full amount of characters
    segments.push(combinedContent.substring(0, lineLength));

    // Pull out the remaining segments which can only use the max length minus the line prefix
    let index = lineLength;
    while (index < combinedContent.length) {
        segments.push(
            combinedContent.substring(index, index + continuationLineLength),
        );
        index += continuationLineLength;
    }

    // Convert array of segments to a single string, using '\r\n ' to continue lines
    return segments.join(continuationPrefix).trimEnd();
};

const generateEvent = (event, date) => {
    const start = generateICSDatetime(date.start, date.allDay);
    const end = generateICSDatetime(date.end, date.allDay, (d) =>
        date.allDay ? addDays(d, 1) : d,
    );

    const UID = generateEventUID(start, end, event.summary);

    const eventObject = {
        UID,
        DTSTAMP: DATE_CREATED,
        DTSTART: start,
        DTEND: end,
        SUMMARY: `MHN: ${event.summary}`,
        DESCRIPTION: event.description,
    };

    const eventFields = Object.entries(eventObject)
        .map(([key, value]) => wordWrap(key, value))
        .join(LINE_BREAK);

    return [
        // Need to join with CR+LF style line endings
        'BEGIN:VEVENT',
        eventFields,
        'END:VEVENT',
    ]
        .join(LINE_BREAK)
        .trim();
};

const generateCalendar = (icsEvents) => {
    const calendarData = {
        PRODID: '-//Seriouslysean//Monster Hunter Now Events Generator//EN',
        URL: 'https://github.com/seriouslysean/monster-hunter-now-events',
        NAME: 'Monster Hunter Now Events',
        DESCRIPTION:
            'Monster Hunter Now Events, see https://github.com/seriouslysean/monster-hunter-now-events for more information.',
        COMMENT:
            'Generated by Monster Hunter Now Events by seriouslysean. Visit https://github.com/seriouslysean/monster-hunter-now-events for more information.',
        'X-URL': 'https://github.com/seriouslysean/monster-hunter-now-events',
        'X-LINK': 'https://github.com/seriouslysean/monster-hunter-now-events',
        'X-WR-CALNAME': 'Monster Hunter Now Events',
        'REFRESH-INTERVAL;VALUE=DURATION': 'P1D',
        COLOR: '255:179:25',
        CALSCALE: 'GREGORIAN',
        METHOD: 'PUBLISH',
    };

    const wrappedCalendarData = Object.entries(calendarData).map(
        ([key, value]) => wordWrap(key, value),
    );

    return [
        // Need to join with CSRF style line endings
        'BEGIN:VCALENDAR',
        'VERSION:2.0',
        ...wrappedCalendarData,
        icsEvents,
        'END:VCALENDAR',
    ]
        .join(LINE_BREAK)
        .trim();
};

export default function generateFeed() {
    try {
        const { events } = getEventsJSON();
        if (!events.length) {
            throw new Error('No events found');
        }
        // Note: Google Calendar stores timed events using UTC timestamps according to the ISO 8601
        // standard (https://tools.ietf.org/html/rfc3339). This means that every timed event
        // corresponds to a fixed point in time which prevents the use of RRULE due to our use of
        // floating times. Big bummer, but it just means a larger ICS file at the end of the day.
        const icsEvents = events.reduce((acc, event) => {
            logger.info(`Adding event: ${event.summary}`);
            const dates = event.dates || [];
            const datesString = dates.length
                ? dates
                      .map((date) => generateEvent(event, date))
                      .join(LINE_BREAK)
                : '';
            return acc ? [acc, datesString].join(LINE_BREAK) : datesString;
        }, '');

        const icsCalendar = generateCalendar(icsEvents);
        saveEventsICS(icsCalendar);
        logger.info('');
        logger.info('Events saved successfully!');
    } catch (err) {
        logger.error(err);
    }
}
